<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>ESP WebSerial Control</title>
    <style>
      body {
        font-family: sans-serif;
        max-width: 600px;
        margin: 20px auto;
        padding: 0 20px;
      }
      #console {
        width: 100%;
        height: 200px;
        margin-top: 10px;
        border: 1px solid #ccc;
        padding: 10px;
        overflow-y: scroll;
        white-space: pre-wrap;
      }
      #canvasContainer {
        width: 100%;
        height: 300px;
        border: 1px solid #ccc;
        margin-top: 20px;
        position: relative;
      }
      .fader-container {
        margin: 1em 0;
      }
      .fader-container label {
        display: inline-block;
        width: 100px;
      }
    </style>
  </head>
  <body>
    <h1>ESP WebSerial Control</h1>

    <button id="connectButton">Connect</button>

    <div id="console"></div>
    <div id="fadersContainer"></div>
    <button id="debugButton">Debug on</button>
    <button id="debugOffButton">Debug off</button>
    <button id="saveButton">Save</button>
    <button id="reloadButton">Discard changes (reload saved settings)</button>
    <button id="resetButton">Reset to factory defaults</button>

    <div id="canvasContainer">
      <canvas id="graphCanvas" width="600" height="300"></canvas>
    </div>

    <script>
      let port;
      let reader;
      let inputDone;
      let outputDone;
      let inputStream;
      let outputStream;
      const consoleElement = document.getElementById("console");
      const connectButton = document.getElementById("connectButton");
      const saveButton = document.getElementById("saveButton");
      const debugButton = document.getElementById("debugButton");
      const debugOffButton= document.getElementById("debugOffButton");
      const reloadButton = document.getElementById("reloadButton");
      const resetButton = document.getElementById("resetButton");

      const fadersContainer = document.getElementById("fadersContainer");
      const canvas = document.getElementById("graphCanvas");
      const ctx = canvas.getContext("2d");

      const lamp1Data = [];
      const lamp2Data = [];

      const faderConfigs = [
        { id: "level_min", label: "Level Min:", min: 0, max: 254, value: 0 },
        { id: "level_max", label: "Level Max:", min: 0, max: 254, value: 250 },
        {
          id: "offset_1",
          label: "Offset 1:",
          min: 0,
          max: 1,
          value: 0,
          suffix: "% of cycle time",
          step: 0.01,
        },
        {
          id: "offset_2",
          label: "Offset 2:",
          min: 0,
          max: 1,
          value: 50,
          suffix: "% of cycle time",
          step: 0.01,
        },
        {
          id: "transition_time",
          label: "Transition Time:",
          min: 0,
          max: 50,
          value: 10,
          suffix: "seconds",
          step: 0.01,
        },
        {
          id: "on_time",
          label: "On Time:",
          min: 0,
          max: 5,
          value: 0,
          suffix: "% of transition_time",
          step: 0.01,
        },
        {
          id: "off_time",
          label: "Off Time:",
          min: 0,
          max: 5,
          value: 0,
          suffix: "% of transition_time",
          step: 0.01,
        },
        {
          id: "gamma_value",
          label: "Gamma:",
          min: 0,
          max: 5,
          value: 2.4,
          step: 0.01,
        },
        {
          id: "smooth",
          label: "Smooth:",
          min: 0,
          max:1,
          value: 0,
          step: 0.01,
        },
      ];

      function createFader(config) {
        const container = document.createElement("div");
        container.className = "fader-container";
        const label = document.createElement("label");
        label.setAttribute("for", `${config.id}Fader`);
        label.textContent = config.label;
        const fader = document.createElement("input");
        fader.type = "range";
        fader.min = config.min;
        fader.max = config.max;
        fader.value = config.value;
        fader.id = `${config.id}Fader`;
        fader.step = config.step;
        const valueSpan = document.createElement("span");
        valueSpan.id = `${config.id}Value`;
        valueSpan.textContent = config.value;

        fader.addEventListener("input", () => {
          valueSpan.textContent = fader.value;
          sendVariableUpdate(config.id, fader.value);
        });

        container.appendChild(label);
        container.appendChild(fader);
        container.appendChild(valueSpan);

        if (config.suffix) {
          const suffixSpan = document.createElement("span");
          suffixSpan.textContent = ` ${config.suffix}`;
          container.appendChild(suffixSpan);
        }

        fadersContainer.appendChild(container);
      }

      faderConfigs.forEach(createFader);
      connectButton.addEventListener("click", async () => {
        await connectToSerial();
        await getVariables();
      });

      saveButton.addEventListener("click", async () => {
        await sendSerialLine("save_light_config");
      });

      debugButton.addEventListener("click",async () => {
        sendSerialLine("log_level * debug");
      });

      debugOffButton.addEventListener("click", () => {
        sendSerialLine("log_level * info");
      });


      reloadButton.addEventListener("click", async () => {
        await sendSerialLine("reload_light_config");
        await getVariables();
        appendToConsole("Reloaded saved settings.\n");
      });

      resetButton.addEventListener("click", async () => {
        await sendSerialLine("reset_light_config");
        await getVariables();
        appendToConsole("Factory defaults have been reset.\n");
      });

      async function connectToSerial() {
        try {
          port = await navigator.serial.requestPort({
            filters: [{ usbVendorId: 0x303a }, { usbVendorId: 0x1a86 }],
          });
          await port.open({ baudRate: 115200, buffersize: 100000 });

          const textEncoder = new TextEncoderStream();
          outputDone = textEncoder.readable.pipeTo(port.writable);
          outputStream = textEncoder.writable;

          const textDecoder = new TextDecoderStream();
          inputDone = port.readable.pipeTo(textDecoder.writable);
          inputStream = textDecoder.readable;

          reader = inputStream.getReader();
          readLoop();
          appendToConsole("> Connected to serial port.\n");
        } catch (e) {
          appendToConsole(`Error: ${e}\n`);
        }
      }

      async function readLoop() {
        let buffer = "";

        while (true) {
          try {
            const { value, done } = await reader.read();

            if (done) {
              reader.releaseLock();
              break;
            }
            if (value) {
              buffer += value;

              let newlineIndex;
              while ((newlineIndex = buffer.indexOf("\n")) !== -1) {
                const line = buffer.slice(0, newlineIndex);
                buffer = buffer.slice(newlineIndex + 1);

                if (line.startsWith("VALUE")) {
                  const parts = line.split(" ");
                  if (parts.length === 3) {
                    const varName = parts[1];
                    const varValue = parts[2];
                    appendToConsole(`Received ${varName}: ${varValue}\n`);

                    const varFader = document.getElementById(`${varName}Fader`);
                    if (varFader) {
                      varFader.value = parseInt(varValue);
                    }
                    const varSpan = document.getElementById(`${varName}Value`);
                    if (varSpan) {
                      varSpan.textContent = varValue;
                    }
                  } else {
                    appendToConsole(`Malformed VALUE command: ${line}\n`);
                  }
                } else if (line.includes("LIGHT_CONTROL: Setting")) {
                  const parts = line.match(/Lamp(\d+) to (\d+)/);
                  if (parts) {
                    const lampNumber = parts[1];
                    const lampValue = parseInt(parts[2]);
                    const now = Date.now();
                    if (lampNumber === "1") {
                      lamp1Data.push({ time: now, value: lampValue });
                    } else if (lampNumber === "2") {
                      lamp2Data.push({ time: now, value: lampValue });
                    }
                    if (lamp1Data.length > 100) lamp1Data.shift();
                    if (lamp2Data.length > 100) lamp2Data.shift();
                    drawGraph();
                  }
                } else {
                  appendToConsole(`${line}\n`);
                }
              }
            }
          } catch (error) {
            appendToConsole(`Read error: ${error}\n`);
          }
        }
      }

      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };

          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      const sendSerialLine = debounce(async function(line) {
        if (!outputStream) {
          return;
        }
        const data = line + "\n";
        const writer = outputStream.getWriter();
        await writer.write(data);
        writer.releaseLock();
      }, 100); // Adjust the debounce time (in milliseconds) as needed

      function sendVariableUpdate(variableName, value) {
        const command = `set ${variableName} ${value}`;
        sendSerialLine(command);
      }

      async function getVariables() {
        sendSerialLine("get");
      }

      function appendToConsole(text) {
        consoleElement.textContent += text;
        consoleElement.scrollTop = consoleElement.scrollHeight;
      }

      function drawGraph() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.beginPath();
        ctx.strokeStyle = "red";
        lamp1Data.forEach((data, index) => {
          const x = (index / 100) * canvas.width;
          const y = canvas.height - (data.value / 255) * canvas.height;
          if (index === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.stroke();

        ctx.beginPath();
        ctx.strokeStyle = "blue";
        lamp2Data.forEach((data, index) => {
          const x = (index / 100) * canvas.width;
          const y = canvas.height - (data.value / 255) * canvas.height;
          if (index === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.stroke();
      }
    </script>
  </body>
</html>
