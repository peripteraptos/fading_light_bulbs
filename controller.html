<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>ESP WebSerial Control</title>
    <style>
      body {
        font-family: sans-serif;
        max-width: 1000px;
        margin: 20px auto;
        padding: 0 20px;
      }
      #console {
        width: 100%;
        height: 200px;
        margin-top: 10px;
        border: 1px solid #ccc;
        padding: 10px;
        overflow-y: scroll;
        white-space: pre-wrap;
      }
      #canvasContainer {
        width: 100%;
        height: 400px;
        border: 1px solid #ccc;
        margin-top: 20px;
        position: relative;
      }
      .fader-container,
      .other-input-container {
        margin: 1em 0;
        display: grid;
        gap: 0px 10px;
        grid-template-columns: 200px 1fr 100px;
      }

      label {
        display: inline-block;
      
        width: 200px;
      }

      .buttonContainer {
        display: flex;
        flex-direction: column;
        margin-top: 1rem;
        gap: 1em;
      }

      .controlContainer {
        display: grid;
        gap: 1em;
        grid-template-columns: 2fr 1fr;
      }
    </style>
  </head>
  <body>
    <h1>ESP WebSerial Control</h1>

    <button id="connectButton">Connect</button>

    <div id="canvasContainer">
      <canvas id="graphCanvas" width="1000" height="400"></canvas>
    </div>
    <div class="controlContainer">

        <div id="fadersContainer"></div>
       
     

      <div class="buttonContainer">
        <button id="debugButton">Debug on</button>
        <button id="debugOffButton">Debug off</button>
        <button id="saveButton">Save</button>
        <button id="reloadButton">
          Discard changes (reload saved settings)
        </button>
        <button id="resetButton">Reset to factory defaults</button>
        <button id="calibrationButton">Start LUT Calibration</button>
      </div>
    </div>
    <div id="console"></div>

    <script>
      let port;
      let reader;
      let inputDone;
      let outputDone;
      let inputStream;
      let outputStream;
      const consoleElement = document.getElementById("console");
      const connectButton = document.getElementById("connectButton");
      const saveButton = document.getElementById("saveButton");
      const debugButton = document.getElementById("debugButton");
      const debugOffButton = document.getElementById("debugOffButton");
      const reloadButton = document.getElementById("reloadButton");
      const resetButton = document.getElementById("resetButton");
      const calibrationButton = document.getElementById("calibrationButton");
      const fadersContainer = document.getElementById("fadersContainer");
      const canvas = document.getElementById("graphCanvas");
      const ctx = canvas.getContext("2d");

      const lamp1Data = [];
      const lamp2Data = [];
      const sensorData = [];
      const faderConfigs = [
        { id: "level_min", label: "Level Min:", type: "range", min: 0, max: 254, value: 0 },
        { id: "level_max", label: "Level Max:", type: "range", min: 0, max: 254, value: 250 },
        {
          id: "offset_1",
          label: "Offset 1:",
          type: "range",
          min: 0,
          max: 1,
          value: 0,
          suffix: "% of cycle time",
          step: 0.01,
        },
        {
          id: "offset_2",
          label: "Offset 2:",
          type: "range",
          min: 0,
          max: 1,
          value: 50,
          suffix: "% of cycle time",
          step: 0.01,
        },
        {
          id: "transition_time",
          label: "Transition Time:",
          type: "range",
          min: 0,
          max: 50,
          value: 10,
          suffix: "seconds",
          step: 0.01,
        },
        {
          id: "on_time",
          label: "On Time:",
          type: "range",
          min: 0,
          max: 5,
          value: 0,
          suffix: "% of transition_time",
          step: 0.01,
        },
        {
          id: "off_time",
          label: "Off Time:",
          type: "range",
          min: 0,
          max: 5,
          value: 0,
          suffix: "% of transition_time",
          step: 0.01,
        },
      {
        id: "gamma_mode",
        label: "Gamma Mode:",
        type: "select",
        options: [
          { value: "0", text: "Linear" },
          { value: "1", text: "Exponential" },
          { value: "2", text: "Polynomial" },
        ],
        value: "0"
      },
      {
        id: "gamma_pow_value",
        label: "Gamma Pow Value:",
        type: "range",
        min: 0,
        max: 5,
        value: 1,
        step: 0.01,
      },
      {
        id: "gamma_pow_scale",
        label: "Gamma Pow Scale:",
        type: "range",
        min: 0,
        max: 5,
        value: 1,
        step: 0.01,
      },
      {
        id: "gamma_pol_a",
        label: "Gamma Pol A:",
        type: "range",
        min: -10,
        max: 10,
        value: 0,
        step: 0.01,
      },
      {
        id: "gamma_pol_b",
        label: "Gamma Pol B:",
        type: "range",
        min: -10,
        max: 10,
        value: 0,
        step: 0.01,
      },
      {
        id: "gamma_pol_c",
        label: "Gamma Pol C:",
        type: "range",
        min: -10,
        max: 10,
        value: 0,
        step: 0.01,
      },
        {
          id: "smooth",
          label: "Smooth:",
          type: "range",
          min: 0,
          max: 1,
          value: 0,
          step: 0.01,
        },

        {
          id: "dimming_strategy",
          label: "Dimming Strategy:",
          type: "select",
          options: [
            { value: "0", text: "Move to Level with Off" },
            { value: "1", text: "Move to Level" },
            { value: "2", text: "Level Move with On Off" },
            { value: "3", text: "Level Move" },
          ],
          value: "normal"
        }
      ];

      function createControl(config) {
        const container = document.createElement("div");
        container.className = "fader-container";
        const label = document.createElement("label");
        label.setAttribute("for", `${config.id}Control`);
        label.textContent = config.label;

        let control;
        if (config.type === "range") {
          control = document.createElement("input");
          control.type = "range";
          control.min = config.min;
          control.max = config.max;
          control.value = config.value;
          control.step = config.step;
        } else if (config.type === "select") {
          control = document.createElement("select");
          config.options.forEach(option => {
            const opt = document.createElement("option");
            opt.value = option.value;
            opt.textContent = option.text;
            control.appendChild(opt);
          });
          control.value = config.value;
        }

        control.id = `${config.id}Control`;
        const valueSpan = document.createElement("span");
        valueSpan.id = `${config.id}Value`;
        valueSpan.textContent = config.value;

        control.addEventListener("input", () => {
          valueSpan.textContent = control.value;
          sendVariableUpdate(config.id, control.value);
        });
        container.appendChild(label);
        container.appendChild(control);
        container.appendChild(valueSpan);

        if (config.suffix && config.type === "range") {
          const suffixSpan = document.createElement("span");
          suffixSpan.textContent = ` ${config.suffix}`;
          container.appendChild(suffixSpan);
        }

        fadersContainer.appendChild(container);
      }
      faderConfigs.forEach(createControl);
      connectButton.addEventListener("click", async () => {
        await connectToSerial();
        await getVariables();
      });

      saveButton.addEventListener("click", async () => {
        if (
          confirm(
            "Do you really want to save the config? The old config will be overwritten."
          )
        ) {
          await sendSerialLine("save_light_config");
        }
      });

      debugButton.addEventListener("click", async () => {
        sendSerialLine("log_level * debug");
      });

      debugOffButton.addEventListener("click", () => {
        sendSerialLine("log_level * info");
      });

      reloadButton.addEventListener("click", async () => {
        if (confirm("Do you really want to reload the config?")) {
          await sendSerialLine("reload_light_config");
          await getVariables();
          appendToConsole("Reloaded saved settings.\n");
        }
      });

      resetButton.addEventListener("click", async () => {
        if (confirm("Do you really want to reset to factory defaults?")) {
          await sendSerialLine("reset_light_config");
          await getVariables();
          appendToConsole("Factory defaults have been reset.\n");
        }
      });

      calibrationButton.addEventListener("click", async () => {
        await sendSerialLine("start_calibration");
      });


      async function connectToSerial() {
        try {
          port = await navigator.serial.requestPort({
            filters: [{ usbVendorId: 0x303a }, { usbVendorId: 0x1a86 }],
          });
          await port.open({ baudRate: 115200, buffersize: 100000 });

          const textEncoder = new TextEncoderStream();
          outputDone = textEncoder.readable.pipeTo(port.writable);
          outputStream = textEncoder.writable;

          const textDecoder = new TextDecoderStream();
          inputDone = port.readable.pipeTo(textDecoder.writable);
          inputStream = textDecoder.readable;

          reader = inputStream.getReader();
          readLoop();
          appendToConsole("> Connected to serial port.\n");
        } catch (e) {
          appendToConsole(`Error: ${e}\n`);
        }
      }

      async function readLoop() {
        let buffer = "";

        while (true) {
          try {
            const { value, done } = await reader.read();

            if (done) {
              reader.releaseLock();
              break;
            }
            if (value) {
              buffer += value;

              let newlineIndex;
              while ((newlineIndex = buffer.indexOf("\n")) !== -1) {
                const line = buffer.slice(0, newlineIndex);
                buffer = buffer.slice(newlineIndex + 1);

                if (line.startsWith("VALUE")) {
                  const parts = line.split(" ");
                  if (parts.length === 3) {
                    const varName = parts[1];
                    const varValue = parts[2];
                    appendToConsole(`Received ${varName}: ${varValue}\n`);

                    const varFader = document.getElementById(`${varName}Control`);
                    if (varFader) {
                      varFader.value = parseInt(varValue);
                    }
                    
                    const varSpan = document.getElementById(`${varName}Value`);
                    if (varSpan) {
                      varSpan.textContent = varValue;
                    }
                  } else {
                    appendToConsole(`Malformed VALUE command: ${line}\n`);
                  }
                } else if (line.includes("LIGHT_CONTROL: Setting")) {
                  const parts = line.match(/Lamp(\d+) to (\d+) within (\d+)ms/);
                  if (parts) {
                    const lampNumber = parts[1];
                    const lampValue = parseInt(parts[2]);
                    const additionalMilliseconds = parseInt(parts[3]);
                    const now = Date.now() + additionalMilliseconds;
                    if (lampNumber === "1") {
                      lamp1Data.push({ time: now, value: lampValue });
                    } else if (lampNumber === "2") {
                      lamp2Data.push({ time: now, value: lampValue });
                    }
                    if (lamp1Data.length > 200) lamp1Data.shift();
                    if (lamp2Data.length > 200) lamp2Data.shift();
                    drawGraph();
                  }
                } else if (line.includes("LIGHT_SENSOR: Value:")) {
                  const value = parseInt(line.match(/Value: (\d+)/)[1]);
                  const now = Date.now();
                  sensorData.push({ time: now, value });
                  if (sensorData.length > 800) sensorData.shift();
                  drawGraph();
                } else {
                  appendToConsole(`${line}\n`);
                }
              }
            }
          } catch (error) {
            appendToConsole(`Read error: ${error}\n`);
          }
        }
      }

      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };

          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      const sendSerialLine = debounce(async function (line) {
        if (!outputStream) {
          return;
        }
        const data = line + "\n";
        const writer = outputStream.getWriter();
        await writer.write(data);
        writer.releaseLock();
      }, 100);
      function sendVariableUpdate(variableName, value) {
        const command = `set ${variableName} ${value}`;
        sendSerialLine(command);
      }

      async function getVariables() {
        sendSerialLine("get");
      }

      function appendToConsole(text) {
        consoleElement.textContent += text;
        consoleElement.scrollTop = consoleElement.scrollHeight;
      }

      function drawGraph() {
        // Define the time window for the graph (e.g., last 10 seconds)
        const timeWindow = 20000; // 10 seconds
        const now = Date.now();

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        function plotData(dataArray, color, minValue, maxValue) {
          ctx.beginPath();
          ctx.strokeStyle = color;
          dataArray.forEach((data, index) => {
            const timeDiff = now - data.time;
            const x = canvas.width - (timeDiff / timeWindow) * canvas.width;
            const y =
              canvas.height -
              ((data.value - minValue) / (maxValue - minValue)) * canvas.height;

            if (x >= 0) {
              if (index === 0 || dataArray[index - 1].time <= now - timeWindow)
                ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }
          });
          ctx.stroke();
        }

        // Plot each dataset with its respective color and max value
        plotData(lamp1Data, "red", 0, 255);
        plotData(lamp2Data, "blue", 0, 255);

        plotData(
          sensorData,
          "green",
          Math.min(...sensorData.map((s) => s.value)),
          Math.max(...sensorData.map((s) => s.value))
        );
      }
    </script>
  </body>
</html>
